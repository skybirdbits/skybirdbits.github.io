<!DOCTYPE html>

<html lang="fa">

<head>

    <meta content="IE=7" http-equiv="X-UA-Compatible">
    <meta content="ie=edge" http-equiv="X-UA-Compatible">

    <meta content="گاهی اوقات نیاز داریم متد ها و فیلد های یک کلاس رو داخل کلاس دیگه پیاده‌سازی کنیم به‌جای اینکه متد و فیلد ها رو دوباره بنویسیم از کلاسی که مایحتاجمونو داره ارث بری میکنیم؛ در این مطلب به بررسی وراثت می پردازیم و در اخر یه نگاهی ام داریم به کلاس Object در جاوا"
          name="description">

    <meta content="text/html;charset=UTF-8" http-equiv="Content-Type">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">

    <title>وراثت (inheritance) در جاوا</title>

    <meta content="وراثت (inheritance) در جاوا" name="og:title">
    <meta content="گاهی اوقات نیاز داریم متد ها و فیلد های یک کلاس رو داخل کلاس دیگه پیاده‌سازی کنیم به‌جای اینکه متد و فیلد ها رو دوباره بنویسیم از کلاسی که مایحتاجمونو داره ارث بری میکنیم؛ در این مطلب به بررسی وراثت می پردازیم و در اخر یه نگاهی ام داریم به کلاس Object در جاوا"
          name="og:description">

    <meta content="https://skybirdbits.github.io/resources/favicon.png" property="og:image">
    <meta content="https://skybirdbits.github.io/article/java/inheritance.html" property="og:url">

    <meta content="article" property="og:type">

    <link href="/resources/favicon.png" rel="shortcut icon" type="image/x-icon">

    <link href="/resources/css/main.css" rel="stylesheet">
    <script src="/resources/js/main.js" type="module"></script>

</head>

<body>
<header></header>
<main>
    <div class="page-wrap">

        <div class="article-head">
            <h1>
                وراثت (inheritance) در جاوا
            </h1>

            <address>
                <a class="author text-muted text-decoration-none" rel="author">یونس سلیمانی</a>
            </address>

            <figure class="figure figure-wrapper">
                <img alt="وراثت (inheritance) در جاوا" class="rounded figure-img" src="/resources/image/java/cover_inheritance.png"/>
            </figure>

            <div class="toc">
                <p class="p-2 mx-2 h5">دسترسی سریع</p>
                <div class="list-group">

                    <a class="list-group-item list-group-item-action" href="#sub0">تعریف وراثت</a>

                    <a class="list-group-item list-group-item-action" href="#sub1">نحوه ی ارث بری از یک کلاس</a>

                    <a class="list-group-item list-group-item-action" href="#sub2">بررسی کانستراکتور ها در ارث بری</a>

                    <a class="list-group-item list-group-item-action" href="#sub3">مفهوم بازنویسی (Overriding)</a>

                    <a class="list-group-item list-group-item-action" href="#sub4">کلاس Object</a>
                    <a class="list-group-item list-group-item-action" href="#sub5">مورد مطالعه (مثال) ها</a>

                    <a class="list-group-item list-group-item-action" href="#sub6">خلاصه</a>
                </div>
            </div>
        </div>

        <article>

            <div class="subsection" id="sub0">
                <p class="title">تعریف وراثت</p>
                <blockquote>وراثت به شما این امکان رو میده تا دیتافیلد و متد های یک کلاس دیگه رو به کلاس جدید منتقل کنید و از دوباره نویسی کدهای تکراری برای کلاس های مختلف جلوگیری میکنه.</blockquote>

                <p>گاهی اوقات نیاز داریم متد ها و فیلد های یک کلاس رو داخل کلاس دیگه پیاده‌سازی کنیم به‌جای اینکه متد و فیلد ها رو دوباره بنویسیم از کلاسی که مایحتاجمونو داره ارث بری میکنیم.</p>

                <p>میتونیم یک کلاس از روی کلاس دیگه تعریف کنیم، در این صورت کلاس جدید علاوه بر دیتافیلد و متد های کلاس قبلی، دیتافیلد و متد های اختصاصی خودش هم میتونه داشته باشه؛ به این کار وراثت یا ارث بری (inheritance) در جاوا میگیم.</p>
                <p>به کلاسی که دیتافیلد و متد های کلاس دیگه رو ارث می بره ساب کلاس (subclass) و به کلاسی که ازش میخوایم ارث بری کنیم، سوپرکلاس (superclass) میگیم.</p>

                <p>به کمک وراثت کلاس های دیگه میتونن دیتافیلد و متدهای سوپرکلاس رو به ارث ببرن.</p>
                <p>به عنوان مثال میدونیم Rectangle و Circle هردو یک شکل هندسی هستند و شکل های هندسی یک سری ويژگی های مشترک بینشون وجود داره (مثل مساحت و محیط) بنابر این میتونیم یک کلاس عمومی به اسم GeometricShape براشون تعریف کنیم.</p>

                <figure>
                    <img alt="ارث بری دو کلاس Circle و Rectangle از GeometricShape در جاوا" class="img-fluid rounded figure-img" src="/resources/image/generic/inheritance_example_diagram.png">
                    <figcaption class="figure-caption text-end p-2 rtl">ارث بری دو کلاس Circle و Rectangle از GeometricShape</figcaption>
                </figure>

                <p>در تصویر بالا GeometricShape سوپرکلاس <strong>(superclass)</strong> است، Rectangle و Circle ساب کلاس <strong>(subclass)</strong> های GeometricShape هستند.</p>

            </div>


            <div class="subsection" id="sub1">
                <p class="title">نحوه ی ارث بری از یک کلاس</p>
                <blockquote>با کلید واژه ی extends در جاوا میتونیم از یک کلاس ارث بری کنیم.</blockquote>

                <p>اگه بخوایم دیتافیلد و متد های یک کلاس رو به ارث ببریم باید از کلیدواژه ی extends در جاوا استفاده کنیم.</p>

                <p>فرم کلی:</p>

                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
public class Parent {
    ...
}

public class Child extends Parent{
    ...
}
                        </div>
                    </div>
                </div>


                <div class="note">
                    <p class="h6">توجه</p>
                    <p>هر کلاسی بیشتر از یک کلاس نمیتونه به طور مستقیم ارث بری کنه.</p>
                </div>

                <p>یک کلاس میتونه به صورت غیر مستقیم از کلاس های دیگه ارث بری داشته باشه در زیر کلاس Child به طور غیر مستقیم از GrandParent ارث بری کرده.</p>

                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
public class GrandParent{
    ...
}

class Parent extends GrandParent{
    ...
}

class Child extends Parent{
    ...
}
                        </div>
                    </div>
                </div>


                <p>هنگام ایجاد آبجکت از ساب کلاس ابتدا فیلد های سوپر کلاس مقداردهی میشن و سپس فیلد های ساب کلاس؛ به این موضوع با جزئیات بیشتر در ادامه و در بخش ویژگی های کانستراکتور خواهیم پرداخت.</p>

                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
class Parent {
    Parent(){
        System.out.println("Initializing Parent");
    }
}

class Child extends Parent{
    Child(){
        System.out.println("Initializing Child");
    }
}
                        </div>
                    </div>
                </div>


                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
public static void main(String[] args){
    Child child = new Child();
}
                        </div>
                    </div>
                </div>


                <p>بعد از ارث بری تمام فیلد ها و متد های سوپرکلاس به ساب کلاس میرسن.</p>

                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
class Parent {

    public void printParentMessage(){
        System.out.println("A message from parent");
    }
}

class Child extends Parent{

    public void printChildMessage(){
        System.out.println("A message from child");
    }
}
                        </div>
                    </div>
                </div>

                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
public static void main(String[] args){
    Child child = new Child();
    child.printParentMessage();
    child.printChildMessage();
}
                        </div>
                    </div>
                </div>


                <div class="note">
                    <p class="h6">توجه:</p>
                    <p>با اینکه تمام دیتافیلد و متدهای سوپرکلاس در ساب کلاس به ارث میرسن، ولی اگه اعضای سوپر کلاس محدودیت دسترسی داشته باشند در ساب کلاس قابل صدا زدن نیستند؛ مثلا اگه متد یا فیلدی در سوپرکلاس private باشه دیگه در ساب کلاس نمیتونیم صداش بزنیم هرچند به ساب کلاس منتقل شده است.</p>
                </div>

                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
class Parent {

    //بخاطر سطح دسترسی که بهش دادیم، در ساب کلاس نمیتونیم صداش بزنیم
    private void printParentMessage(){
        System.out.println("A message from parent");
    }
}

class Child extends Parent{

    public void printChildMessage(){
        System.out.println("A message from child");
    }
}
                        </div>
                    </div>
                </div>

            </div>
            <div class="subsection" id="sub2">
                <p class="title">بررسی کانستراکتور ها در وراثت</p>

                <p>بر خلاف فیلد ها و متد ها، کانستراکتور های سوپرکلاس به ساب کلاس منتقل نمیشن و فقط میتونیم اونا رو داخل کانستراکتور های ساب کلاس صدا بزنیم.</p>

                <p>هنگام تعریف کانستراکتور برای ساب کلاس حتما باید یکی از کانستراکتور های سوپر کلاس رو در کانستراکتور های ساب کلاس صدا بزنیم.</p>
                <p class="piece">۱- صدا زدن مستقیم کانستراکتور سوپر کلاس:</p>
                <p>با استفاده از کلیدواژه ی <strong>super</strong> میتونیم یکی از کانستراکتور های سوپر کلاس رو داخل کانستراکتور ساب کلاس صدا بزنیم.</p>

                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
//اگه کانستراکتو درر سوپر کلاس پارامتر داشت پارامتر ها رو داخل پرانتز سوپر پاس میدیم.
super(p0, p1, ..., pn);

//اگه کانستراکتور در سوپرکلاس بدون پارامتر بود.
super();
                        </div>
                    </div>
                </div>


                <p class="piece">2- صدا زدن غیرمستقیم کانستراکتور های سوپر کلاس در ساب کلاس:</p>
                <p>با کلیدواژه ی this میتونیم کانستراکتوری که در ساب کلاس از super استفاده میکنه رو صدا بزنیم.</p>

                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
class Child extends Parent{

    Child(...){
        super(...);
    }

    Child(...){
        this(...);
    }

}
                        </div>
                    </div>
                </div>

                <div class="note">
                    <p class="h6">توجه:</p>
                    <p>تنها در حالتی که سوپرکلاس کانستراکتور بدون پارامتر وجود داشته باشه میتونیم برای کانستراکتور های ساب کلاس از super استفاده نکنیم، در این وضعیت کامپایلر به طور خودکار <strong>&#x200e;super()</strong> رو قبل از هر کدی در کانستراکتور هایی که از super استفاده نکردیم قرار میده.</p>
                </div>

                <div class="note">
                    <p class="h6">توجه:</p>
                    <p>کلیدواژه های super یا this باید داخل کانستراکتوری که داریم تعریف میکنیم قبل از هر کدی قرار بگیرند.</p>
                </div>

                <p>مثال</p>

                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
class GeometricShape{
    private String color;
    private boolean filled;

    GeometricShape(String color, boolean filled){
        this.color = color;
        this.filled = filled;
    }

}

class Circle extends GeometricShape{
    private double radius;

    Circle(double radius, String color, filled){
        super(color , filled);
        this.radius = radius;
    }

    Circle(){
        this(1.0, "White" , false);
    }
}
                        </div>
                    </div>
                </div>


                <p class="piece">زنجیره ی کانستراکتور ها</p>
                <p>میدونیم که با صدا زدن کانستراکتور یک نمونه از کلاس تولید میکنیم؛ هنگام صدا زدن یکی از کانستراکتور های ساب کلاس برای تولید یک نمونه از ساب کلاس، ابتدا کانستراکتور سوپر کلاس صدا زده میشه و اگه خود سوپرکلاس، ساب کلاس یک سوپر کلاس دیگه باشه قبل از اجرای کد های کانستراکتور سوپرکلاس، کانستراکتور قبلی صدا زده میشه و به همین ترتیب تا به آخرین سوپرکلاس برسیم؛ سپس کد های داخل کانستراکتور اخرین سوپر کلاس اجرا میشن و به همین ترتیب تا برسه به کلاسی که ساب کلاس ماست. به این موضوع زنجیره ی کانستراکتور ها میگیم.</p>

                <p>مثال:</p>


                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
public class Faculty extends Employee {
    public static void main(String[] args) {
        new Faculty();
    }
    public Faculty() {
        System.out.println("(4) Performs Faculty's tasks");
    }
}

class Employee extends Person {
    public Employee() {
        this("(2) Invokes Employee's overloaded constructor");
        System.out.println("(3) Performs Employee's tasks ");
    }

    public Employee(String s) {
        System.out.println(s);
    }
}

class Person {
    public Person() {
        System.out.println("(1) Performs Person's tasks");
    }
}
                        </div>
                    </div>
                </div>

                <p>در زیر Person سوپرکلاس همه ی کلاس هاست ابتدا کانستراکتور Person اجرا میشه و چون در Employee با this کانستراکتور پارامتر دارشو داخل کانستراکتور بدون پارامترش صدا زدیم کانستراکتور پارامتر دار اجرا میشه و سپس بقیه کد های کنستراکتور بدون پارامترش و در نهایت کد های داخل کانستراکتور Faculty اجرا میشن.</p>

            </div>


            <div class="subsection" id="sub3">
                <p class="title">مفهوم باز نویسی (Overriding)</p>

                <blockquote>بازنویسی متد به شما این امکان را می دهد تا کدهای داخل متد در سوپر کلاس رو تغییر بدید.</blockquote>


                <p>میتونیم متد های سوپر کلاس رو داخل ساب کلاس بازنویسی کنیم. برای این کار کافیه تا متد با اسم و پارامتر هایی که در سوپرکلاس تعریف شده رو در ساب کلاس دوباره بنویسیم. به این کار باز نویسی (Override کردن) متد میگن.</p>


                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
public class Main{
    public static void main(String[] args){
        Child child = new Child();
        child.printMessage("First");
    }
}

class Parent{
    public void printMessage(String s){
        System.out.println(s + " message from parent");
    }
}

class Child extends Parent{
    //متد باز نویسی شده
    public void printMessage(String s){
        System.out.println(s + " message from child");
    }
}
                        </div>
                    </div>
                </div>

                <p>شاید در برنامه خیلی مشخص نباشه که متد بازنویسی شده برای همین به لحاظ خوانایی کد میتونیم قبل از بازنویسی متد از برچسب <strong>&#x200e;@Override</strong> استفاده کنیم.</p>


                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
public class Main{
    public static void main(String[] args){
        Child child = new Child();
        child.printMessage("First");
    }
}

class Parent{
    public void printMessage(String s){
        System.out.println(s + " message from parent");
    }
}

class Child extends Parent{
    @Override
    public void printMessage(String s){
        System.out.println(s + " message from child");
    }
}
                        </div>
                    </div>
                </div>


                <p class="piece">استفاده از کلیدواژه ی super داخل متد های بازنویسی شده</p>

                <p>هنگام بازنویسی متد، میتونیم با کلیدواژه ی super کدهای متد در سوپرکلاس رو صدا بزنیم.</p>

                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
public class Main{
    public static void main(String[] args){
        Child child = new Child();
        child.printMessage("First");
    }
}

class Parent{
    public void printMessage(String s){
        System.out.println(s + " message from parent");
    }
}

class Child extends Parent{
    @Override
    public void printMessage(String s){
        super.printMessage("First");
        System.out.println(s + " message from child");
    }
}
                        </div>
                    </div>
                </div>


                <p>بر خلاف کانستراکتور ها که super باید قبل از هر کدی داخلشون پیاده میشد در متد ها فرقی نداره در کجای متد از super استفاده کنیم و همینطور دفعات استفاده از super نیز مهم نیست و با هربار صدا زدن super در متد بازنویسی شده، کد های متد در سوپرکلاس اجرا میشن.</p>

                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
public class Main{
    public static void main(String[] args){
        Child child = new Child();
        child.printMessage("First");
    }
}

class Parent{
    public void printMessage(String s){
        System.out.println(s + " message from parent");
    }
}

class Child extends Parent{
    @Override
    public void printMessage(String s){
        super.printMessage("First");
        System.out.println(s + " message from child");
        super.printMessage("Second");
    }
}
                        </div>
                    </div>
                </div>
            </div>


            <div class="subsection" id="sub4">
                <p class="title">کلاس Object</p>
                <blockquote>کلاس Object سوپرکلاس مستقیم یا غیر مستقیم تمام کلاس های جاواست.</blockquote>
                <p>هنگامی که یک کلاس تعریف میکنیم کلاسمون به طور پیشفرض از Object ارث بری میکنه.</p>
                <p>داخل کلاس Object متد های <strong>hashCode، toString و equals</strong> تعریف شده که این متد ها در کلاس های مختلف بنابر نیاز توسعه دهنده بازنویسی میشن.</p>

                <p>مثال</p>

                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
public class Point2D {

    private double x, y;

    public Point2D(double x, double y){
        this.x = x;
        this.y = y;
    }


    public double getX() {
        return x;
    }

    public void setX(double x) {
        this.x = x;
    }

    public double getY() {
        return y;
    }

    public void setY(double y) {
        this.y = y;
    }

    @Override
    public String toString() {
        return "[x= " + x + ", y= " + y + "]";
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Point2D)
            return ((Point2D) obj).x == this.x && ((Point2D) obj).y == this.y;

        return false;
    }
}
                        </div>
                    </div>
                </div>


                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
public static void main(String[] args){
    Point2D p0 = new Point2D(3, 5);
    Point2D p1 = new Point2D(6, 7);
    Point2D p2 = new Point2D(3,5);

    System.out.println("p0: " + p0.toString());
    System.out.println("p1:" + p1.toString());
    System.out.println("p2: " + p2.toString());

    System.out.println("Are p0 and p1 equal? " + p0.equals(p1));
    System.out.println("Are p0 and p2 equal? " + p0.equals(p2));

}
                        </div>
                    </div>
                </div>

            </div>


            <div class="subsection" id="sub5">
                <p class="title">مورد مطالعه (مثال ها)</p>

                <p>در زیر کلاس های Circle و Rectangle از کلاس GeometricShape ارث برده اند.</p>

                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet Java">
public class GeometricShape {

    private final Date dateCreated = new Date();
    private String color;
    private boolean filled;

    public GeometricShape(String color, boolean filled){
        this.color = color;
        this.filled = filled;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public Date getDateCreated() {
        return dateCreated;
    }

    public boolean isFilled() {
        return filled;
    }

    public void setFilled(boolean filled) {
        this.filled = filled;
    }

}

class Circle extends GeometricShape{
    private double radius;

    public Circle(double radius, String color, boolean filled){
        super(color, filled);
        this.radius = radius;
    }

    public Circle(double radius){
        this(radius, "white", false);
    }

    public double getRadius() {
        return radius;
    }

    public void setRadius(double radius) {
        this.radius = radius;
    }

    public double getArea(){
        return Math.PI * radius * radius;
    }

    public double getPerimeter(){
        return 2 * Math.PI * radius;
    }

    @Override
    public String toString() {
        return "Circle: created on " + getDateCreated().toString() + "\n" +
            "radius: " + getRadius() + " area: " + getArea() + " perimeter " + getPerimeter();
    }
}

class Rectangle extends GeometricShape{
    private double width;
    private double height;


    public Rectangle(double width , double height, String color, boolean filled){
        super(color, filled);
        this.width = width;
        this.height = height;
    }

    public Rectangle(){
        this(1.0, 1.0, "White", false);
    }

    public double getWidth() {
        return width;
    }

    public void setWidth(double width) {
        this.width = width;
    }

    public double getHeight() {
        return height;
    }

    public void setHeight(double height) {
        this.height = height;
    }

    public double getArea(){
        return width * height;
    }

    public double getPerimeter(){
        return (width + height) * 2;
    }

    @Override
    public String toString() {
        return "Rectangle: created on " + getDateCreated().toString() + "\n" +
            "width: " + getWidth() + " height: " + getHeight() + " area: " + getArea() + " perimeter: " + getPerimeter();
    }
}
                        </div>
                    </div>
                </div>


                <p>استفاده از کلاس های Rectangle و Circle.</p>


                <div class="sample">
                    <div class="snippet-container">
                        <div class="snippet">
public static void main(String[] args){
    Rectangle rectangle = new Rectangle(2,4, "Red", true);
    System.out.println(rectangle.toString());

    System.out.println();

    Circle circle = new Circle(4, "Blue", true);
    System.out.println(circle.toString());
}
                        </div>
                    </div>
                </div>

                <div class="subsection" id="sub6">
                    <p class="title">خلاصه</p>
                    <p>- از ارث بری برای انتقال فیلد ها و متد ها از یک کلاس به کلاس دیگه بدون دوباره نویسی اونا استفاده میکنیم.</p>
                    <p>- به کلاسی که ازش ارث بری میکنیم سوپرکلاس و به کلاسی که ارث میبره ساب کلاس میگیم.</p>
                    <p>- در جاوا فقط از یک کلاس میتونیم ارث بری کنیم.</p>
                    <p>- با کلیدواژه ی extends از یک کلاس ارث بری میکنیم.</p>
                    <p>- در ارث بری کانستراکتور های سوپرکلاس به ساب کلاس منتقل نمیشن.</p>
                    <p>- هنگام ارث بری هر کانستراکتور در ساب کلاس باید حداقل یکی از کانستراکتور های سوپرکلاس رو داخل خودش صدا بزنه.</p>
                    <p>- برای صدا زدن کانستراکتور های سوپرکلاس در ساب کلاس دو راه وجود داره: ۱- مستقیم با استفاده از کلیدواژه ی super؛ ۲- صدا زدن غیر مستقیم یکی از کانستراکتور های داخل کلاس که یکی از کانستراکتور های سوپر کلاس رو صدا زده باشه.</p>
                    <p>- اگه یکی از کانستراکتور های سوپرکلاس بدون پارامتر باشه نیاز به صدا زدنش نیست و کامپایلر به طور خودکار کانستراکتور بدون پارامتر رو برای کانستراکتور هایی که در ساب کلاس از super استفاده نکردیم در نظر میگیره.</p>
                    <p>- کلیدواژه ی super در کانستراکتور ها باید قبل از هر کد دیگه ای در کانستراکتور تعریف بشه.</p>
                    <p>- هنگام ایجاد آبجکت از یک ساب کلاس به طور خودکار کانستراکتور کلاسی که ازش ارث بری کردیم قبل از کانستراکتور خود کلاس اجرا میشه و علت این موضوع صدا زدن اجباری کانستراکتور سوپرکلاس قبل از کد های داخل کانستراکتور ساب کلاس است.</p>
                    <p>- میتونیم یک متد از سوپرکلاس رو در ساب کلاس بازنویسی کنیم. و همینطور با کلیدواژه ی super کد های داخل متد در سوپرکلاس رو صدا بزنیم.</p>
                    <p>- کلاس Object سوپرکلاس مستقیم یا غیر مستقیم تمام کلاس هاست.</p>
                    <p>- در کلاس آبجکت سه متد hashCode، toString و equals تعریف شده که میتونیم به طور اختصاصی در هر کلاسی که تعریف میکنیم بازنویسیشون کنیم.</p>
                </div>

            </div>


        </article>

        <div class="article-foot">

            <div class="navigator-container">

                <a class="md-bt md-bt-light" href="polymorphism.html">
            <span class="material-icons">
              navigate_next
            </span>
                    <span class="hint">
              بعدی
            </span>
                </a>

                <a class="md-bt md-bt-light" href="nested-classes.html">
            <span class="hint">
              قبلی
            </span>
                    <span class="material-icons">
              navigate_before
            </span>

                </a>
            </div>

            <div class="relative-articles-container">
                <p>مطالب مرتبط</p>
                <div>
                    <div>
                        <a href="polymorphism.html">چندریختی و کست کردن در جاوا</a>
                    </div>

                    <div>
                        <a href="objects-and-classes.html">آبجکت و کلاس ها در جاوا</a>
                    </div>

                    <div>
                        <a href="nested-classes.html">کلاس های تو در تو</a>
                    </div>

                    <div>
                        <a href="exceptions.html">اکسپشن ها در جاوا</a>
                    </div>

                </div>
            </div>
        </div>

    </div>
</main>

<div class="scroll-top-container">
    <a class="text-decoration-none link-dark material-icons" href="#">
        arrow_drop_up
    </a>
</div>

<footer></footer>

<div class="copy-message">
    <span class="copy-message-text">کپی شد!</span>
</div>

</body>