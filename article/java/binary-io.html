<!DOCTYPE html>

<html lang="fa">

<head>

  <meta http-equiv="X-UA-Compatible" content="IE=7">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  <meta name="description" content="همه ی فایل ها در کامپیوتر به صورت باینری ذخیره میشن؛ در این مطلب کلاس های text-io رو با binary-io در جاوا مقایسه میکنیم؛ سپس چندتا از کلاس های پر کاربرد binary-io رو مورد بررسی قرار میدیم.">

  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>خوندن و نوشتن فایل های باینری در جاوا</title>

  <meta name="og:title" content="">
  <meta name="og:description" content="">

  <meta property="og:image" content="https://skybirdbits.github.io/resources/favicon.png">
  <meta property="og:url" content="https://skybirdbits.github.io/article/kotlin/">

  <meta property="og:type" content="article">

  <link rel="shortcut icon" href="/resources/favicon.png" type="image/x-icon">

  <link rel="stylesheet" href="/resources/css/main.css">
  <script type="module" src="/resources/js/main.js"></script>

</head>

<body>
<header></header>
<main>
  <div class="page-wrap">

    <div class="article-head">
      <h1>
        خوندن و نوشتن فایل های باینری در جاوا
      </h1>

      <address>
        <a class="author text-muted text-decoration-none" rel="author">یونس سلیمانی</a>
      </address>

      <figure class="figure figure-wrapper">
        <img alt="" class="rounded figure-img" src="/resources/image/java/cover_binary_io.png" />
      </figure>

      <div class="toc">
        <p class="p-2 mx-2 h5">دسترسی سریع</p>
        <div class="list-group">

            <a class="list-group-item list-group-item-action" href="#sub0">مقایسه ی فایل های متنی (text) با فایل های باینری (binary)</a>
            <a class="list-group-item list-group-item-action" href="#sub1">کلاس های Binary-io در جاوا</a>
            <a class="list-group-item list-group-item-action" href="#sub2">کلاس FileInputStream و FileOutputStream در جاوا</a>
            <a class="list-group-item list-group-item-action" href="#sub3">کلاس DataInputStream و DataOutputStream در جاوا</a>
            <a class="list-group-item list-group-item-action" href="#sub4">کلاس ObjectInputStream و ObjectOutputStream در جاوا</a>
            <a class="list-group-item list-group-item-action" href="#sub6">کلاس BufferedInputStream و BufferedOutputStream در جاوا</a>
            <a class="list-group-item list-group-item-action" href="#sub7">مورد مطالعه</a>
            <a class="list-group-item list-group-item-action" href="#sub8">خلاصه</a>
        </div>
      </div>
    </div>

    <article>
      <div class="subsection" id="sub0">
        <p class="title">مقایسه ی کلاس های text-io با binary-io</p>
        <blockquote>تمام فایل هایی که در حافظه ذخیره میشن از نوع باینری هستند.</blockquote>
        <p>برای کامپیوتر فرقی نداره یک فایل از چه نوعی (متنی، تصویری یا...) باشه؛ تمام فایل ها در کامپیوتر به صورت باینری ذخیره میشن؛ تنها چیزی که یک فایل متنی رو با باینری در جاوا متمایز میکنه رمزنگاری و رمزگشایی کاراکترهای (حروف) فایل متنی است.</p>
        <p>هنگامی که بخوایم یک کاراکتر رو داخل فایل ذخیره کنیم ابتدا کاراکتر به کد متناظر خودش تبدیل میشه و سپس این کد که یک عدد است توسط کلاس مربوطه در فایل نوشته میشه. به این فرایند رمزنگاری (encoding) کاراکتر میگیم.</p>

        <p>با هربار نوشتن کاراکتر در فایل توسط کلاس هایی مانند <a class="text-decoration-none" href="printwriter.html">PrintWriter</a> در جاوا مشابه عملیات زیر اتفاق میوفته.</p>

        <div class="sample">
          <div class="snippet-container">
            <div class="snippet Java">
char ch = 'A';
//encoding A
int code = (int) ch;

System.out.println("The code for character A is " + code);
            </div>
          </div>
        </div>

        <p>هنگامی که بخوایم یک کاراکتر رو از فایل متنی بخونیم ابتدا کد متناظر با کاراکتر در فایل متنی توسط برنامه خونده شده و سپس این کد توسط jvm به کاراکتر (حرف) مورد نظر تبدیل شده و نمایش داده میشه. به این فرایند رمزگشایی (decoding) کاراکتر میگیم.</p>

        <p>با خوندن هر کاراکتر (حرف) از فایل توسط کلاس هایی مانند <a class="text-decoration-none" href="scanner.html">Scanner</a> در جاوا مشابه عملیات زیر اتفاق میوفته.</p>

        <div class="sample">
          <div class="snippet-container">
            <div class="snippet Java">
int code = 66;
char ch = (char) code;
System.out.println("The character for code  " + code + " is " + ch);
            </div>
          </div>
        </div>

        <p>کلاس های binary-io سریع تر از کلاس های text-io هستند چون هنگام خوندن و نوشتن درگیر فرایند رمزگشایی و رمزنگاری نمیشن.</p>
          <p>جاوا کلاس های مختلفی برای فرایند io تعریف شده در ادامه ی این مطلب به چندتا از کلاس باینری پکیج io در جاوا می پردازیم.</p>


      </div>

      <div class="subsection" id="sub1">
          <p class="title">کلاس های Binary-io در جاوا</p>

          <blockquote>کلاس های InputStream و OutputStream سوپرکلاس تمام کلاس های پکیج io در جاوا هستند.</blockquote>


          <p>در جاوا برای عملیات io کلاس مختلفی طراحی شده که در این قسمت میخوایم به مهم ترین و پرکاربردترینشون که اساس یادگیری سایر کلاس های پکیج io در جاوا هستند بپردازیم.</p>

          <p>در شکل زیر به رابطه ی بین کلاس هایی که قراره در این مطلب بهشون پرداخته بشه نشون دادیم.</p>

          <figure class="figure figure-wrapper">
              <img class="rounded figure-img" src="/resources/image/java/java_io_inheritance_hierarchy.png" alt="سلسله مراتب ارث بری کلاس های Binary IO در جاوا"/>
              <figcaption class="figure-caption">سلسله مراتب ارث بری کلاس های Binary IO در جاوا</figcaption>
          </figure>

          <p>همونطور که مشاهده کردید تمام کلاس های استریم در تصویر از کلاس های InputStream و OutputStream ارث بری میکنن، این دو کلاس <a class="text-decoration-none" href="abstract-classes.html">ابسترکت</a> هستند و ازشون نمیتونیم شی سازی کنیم و فقط برای ارث بری سایر کلاس ها ساخته شده اند.</p>
          <p>کلاس InputStream سوپر کلاس تمام کلاس های Input و کلاس OutputStream سوپر کلاس تمام کلاسهای Output در پکیج io است.</p>


          <p>دو نمودار uml زیر متد (تابع) های تعریف شده در این دو کلاس رو نشون میدن.</p>

          <div class="tb" id="uml_input_stream">
              <div class="tRow">
                  <div class="tHead">java.io.InputStream</div>
              </div>

              <div class="tRow">
                  <div class="tDataLTR">read(): int</div>
                  <div class="tDataRTL">یک بایت از فایل رو میخونه و اگه به انتهای فایل برسه -1 رو بر میگردونه.</div>
              </div>

              <div class="tRow">
                  <div class="tDataLTR">read(b: byte[]): int</div>
                  <div class="tDataRTL">به اندازه ی طول آرایه ی b از فایل بایت میخونه و تعداد بایت هایی که خونده رو به صورت integer برمیگردونه و اگه به اخر فایل برسه -1 رو بر میگردونه.</div>
              </div>

              <div class="tRow">
                  <div class="tDataLTR">available(): int</div>
                  <div class="tDataRTL">میگه چندتا بایت باقی مونده و اگه به انتهای فایل رسیده باشیم مقدار 0 رو بر میگردونه.</div>
              </div>

              <div class="tRow">
                  <div class="tDataLTR">skip(n: long): long</div>
                  <div class="tDataRTL">تعداد n بایت از فایل رو نادیده میگیره و تعداد نادیده گرفته شده رو بر میگردونه.</div>
              </div>

              <div class="tRow">
                  <div class="tDataLTR">+close()</div>
                  <div class="tDataRTL">استریم فعلی رو میبنده و منابع درگیر رو آزاد میکنه استفاده از close در پایان کار ضروریه.</div>
              </div>
          </div>


          <div class="tb" id="uml_output_stream">
              <div class="tRow">
                  <div class="tHead">java.io.InputStream</div>
              </div>

              <div class="tRow">
                  <div class="tDataLTR">write(b: int): void</div>
                  <div class="tDataRTL">مقدار یک بایت رو در فایل مینویسه.</div>
              </div>

              <div class="tRow">
                  <div class="tDataLTR">write(b: byte[]): void</div>
                  <div class="tDataRTL">بایت های داخل آرایه ی b رو در فایل می نویسه.</div>
              </div>

              <div class="tRow">
                  <div class="tDataLTR">flush(): void</div>
                  <div class="tDataRTL">پس از پایان کار صدا زدن این متد توصیه میشه چون مقادیر باقی مونده ای که در buffer وجود دارند و ممکنه هنوز نوشته نشده باشن رو در فایل مینویسه.</div>
              </div>

              <div class="tRow">
                  <div class="tDataLTR">+close()</div>
                  <div class="tDataRTL">استریم فعلی رو میبنده و منابع درگیر رو آزاد میکنه استفاده از close در پایان کار ضروریه.</div>
              </div>
          </div>

      </div>


        <div class="subsection" id="sub2">
            <p class="title">کلاس های FileInputStream و FileOutputStream در جاوا</p>

            <p>دو کلاس FileInputStream و FileOutputStream به ترتیب از کلاس های InputStream و OutputStream ارث بری کردن و فقط کانستراکتور براشون تعریف شده و سایر فیلد و متد ها رو از سوپر کلاس هاشون به ارث می برن.</p>

            <p>نمودار UML مربوط به FileInputStream در جاوا</p>

            <div class="tb" id="uml_file_input_stream">
                <div class="tRow">
                    <div class="tHead">java.io.FileInputStream</div>
                </div>
                <div class="tRow">
                    <div class="tDataLTR">+FileInputStream(path: String)</div>
                    <div class="tDataRTL">یک نمونه از FileInputStream با پاس دادن String به کانستراکتور ایجاد میکنه؛ String مسیر فایل مورد نظر است.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+FileInputStream(file: File)</div>
                    <div class="tDataRTL">یک نمونه از FileInputStream با پاس دادن File به کانستراکتور ایجاد میکنه.</div>
                </div>
            </div>


            <p>نمودار UML مربوط به FileOutputStream در جاوا</p>
            <div class="tb" id="uml_file_output_stream">
                <div class="tRow">
                    <div class="tHead">java.io.FileOutputStream</div>
                </div>
                <div class="tRow">
                    <div class="tDataLTR">+FileOutputStream(path: String)</div>
                    <div class="tDataRTL">یک نمونه از FileOutputStream با پاس دادن String به کانستراکتور ایجاد میکنه؛ String مسیر فایل مورد نظر است.</div>
                </div>


                <div class="tRow">
                    <div class="tDataLTR">+FileOutputStream(path: String, append: boolean)</div>
                    <div class="tDataRTL">یک نمونه از FileOutputStream با پاس دادن String و مقدار boolean به کانستراکتور ایجاد میکنه؛ String مسیر فایل مورد نظر است و اگه فایل از قبل وجود داشته باشه و مقدار boolean برابر با true باشه داده ها رو ادامه ی فایل می نویسه و اگه false باشه فایل رو حذف کرده و یک فایل جدید ایجاد میکنه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+FileOutputStream(file: File)</div>
                    <div class="tDataRTL">یک نمونه از FileOutputStream با پاس دادن File به کانستراکتور ایجاد میکنه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+FileOutputStream(file: File, append: boolean)</div>
                    <div class="tDataRTL">یک نمونه از FileOutputStream با پاس دادن File به کانستراکتور ایجاد میکنه. اگه فایل از قبل وجود داشته باشه و مقدار boolean برابر با true باشه داده ها رو ادامه ی فایل می نویسه و اگه false باشه فایل رو حذف کرده و یک فایل جدید ایجاد میکنه.</div>
                </div>
            </div>

            <p>در مثال زیر میخوایم یک فایل به نام temp.dat با FileOutputStream ایجاد کنیم و سپس مقادیر بایت ها رو در فایل نوشته و در نهایت فایل رو با FileInputStream بخونیم.</p>


            <div class="note">
                <p class="h6">نکته</p>
                <p>تمام کلاس های io-stream در جاوا حامل <a class="text-decoration-none" href="exceptions.html">checked-exception</a> هستند یعنی باید حتما اکسپشن هاشون رو هندل کنیم اما در کاتلین checked-exception وجود نداره. </p>
            </div>

            <div class="sample">
                <div class="snippet-container">
                    <div class="snippet Java">
public static void main(String[] args) throws IOException{

    try(FileOutputStream output = new FileOutputStream("temp.dat")) {
        for (int i =0; i<10; i++)
        output.write(i);
    }

    try(FileInputStream input = new FileInputStream("temp.dat")){
        int value;
        while ((value =  input.read()) != -1){
            System.out.print(value + " ");
        }
    }
}
                    </div>

                    <div class="snippet Kotlin">
fun main() {

    val file = File("temp.dat")

    val output = FileOutputStream(file)
    for (i in 0 until 10) {
        output.write(i)
    }
    output.close()

    val input = FileInputStream(file)
    var b: Int
    do {
        b = input.read()
        print("$b ")
    }while (b != -1)
    output.close()
}
                    </div>
                </div>
            </div>
            <p>برای جلوگیری از دست رفتن داده ها و اطمینان از نوشته شدن تمام داده ها در فایل ضروریه که در پایان کار متد close رو صدا بزنیم اما در قسمت جاوا در مثال بالا این کار رو نکردیم. چرا؟</p>
            <p>تمام کلاس های io در جاوا از AutoClosable ارث بری میکنن این اینترفیس مشخص میکنه که کلاس یک io-stream است پس باید متد close در پایان کار صدا زده بشه. بنابراین میتونیم از کلاس های io-stream در try-catch مانند بالا داخل پرانتز یک نمونه ایجاد کنیم.</p>
            <p>به این نوع از try-catch، در جاوا <strong>try-with-resources</strong> گفته میشه. در این حالت سیستم پس از پایان کار به طور خودکار stream ایجاد شده داخل پرانتز رو می بنده و نیازی به صدا زدن close نداریم. </p>
        </div>

        <div class="subsection" id="sub3">
            <p class="title">کلاس های DataInputStream و DataOutputStream در جاوا</p>
            <p>وظیفه ی این کلاس ها نوشتن و خوندن مقادیر primitive و string داخل فایل است. در این دو کلاس به ترتیب <a class="text-decoration-none" href="interfaces.html">اینترفیس</a> های DataInput و DataOutput پیاده‌سازی شده است.</p>

            <p>تصویر زیر ارث بری دو کلاس DataInputStream و DataOutputStream رو نشان می دهد.</p>

            <figure class="figure figure-wrapper">
                <img class="rounded figure-img" src="/resources/image/java/java_data_io_stream_inheritance.png" alt="ارث بری دو کلاس DataInputStream و DataOutputStream در جاوا"/>
                <figcaption class="figure-caption rtl">ارث بری دو کلاس DataInputStream و DataOutputStream در جاوا</figcaption>
            </figure>

            <p>همانطور که در تصویر بالا مشاهده کردید برای این کلاس ها فقط یک کانستراکتور تعریف شده که اونم مقادیری از جنس InputStream و OutputStream رو میتونیم به صورت پارامتر بهشون پاس بدیم.</p>


            <p>بررسی متد های اینترفیس DataInput</p>

            <div class="tb" id="data_input_uml">
                <div class="tRow">
                    <div class="tHead">java.io.DataInput</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+readBoolean(): boolean</div>
                    <div class="tDataRTL">مقدار boolean رو از فایل میخونه و برمیگردونه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+readByte(): byte</div>
                    <div class="tDataRTL">مقدار byte رو از فایل میخونه و بر میگردونه.</div>
                </div>


                <div class="tRow">
                    <div class="tDataLTR">+readChar(): char</div>
                    <div class="tDataRTL">مقدار char رو از فایل میخونه و بر میگردونه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+readFloat(): float</div>
                    <div class="tDataRTL">مقدار float رو از فایل میخونه و بر میگردونه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+readDouble(): double</div>
                    <div class="tDataRTL">مقدار double رو از فایل میخونه و بر میگردونه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+readInt(): int</div>
                    <div class="tDataRTL">مقدار int رو از فایل میخونه و بر میگردونه.</div>
                </div>


                <div class="tRow">
                    <div class="tDataLTR">+readLong(): long</div>
                    <div class="tDataRTL">مقدار long رو از فایل میخونه و بر میگردونه.</div>
                </div>


                <div class="tRow">
                    <div class="tDataLTR">+readShort(): short</div>
                    <div class="tDataRTL">مقدار short رو از فایل میخونه و بر میگردونه.</div>
                </div>


                <div class="tRow">
                    <div class="tDataLTR">+readLine(): String</div>
                    <div class="tDataRTL">مقدار String رو از فایل میخونه و بر میگردونه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+readString(): String</div>
                    <div class="tDataRTL">مقدار String رو به صورت UTF از فایل میخونه و بر میگردونه.</div>
                </div>
            </div>

            <p>بررسی متد های اینترفیس DataOutput</p>
            <div class="tb" id="data_output_uml">
                <div class="tRow">
                    <div class="tHead">java.io.DataOutput</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+writeBoolean(b: boolean): void</div>
                    <div class="tDataRTL">مقدار boolean رو داخل فایل می نویسه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+writeChar(c: char): void</div>
                    <div class="tDataRTL">مقدار char رو داخل فایل می نویسه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+writeFloat(f: float): void</div>
                    <div class="tDataRTL">مقدار float رو داخل فایل می نویسه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+writeDouble(d: double): void</div>
                    <div class="tDataRTL">مقدار double رو داخل فایل می نویسه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+writeInt(i: int): void</div>
                    <div class="tDataRTL">مقدار int رو داخل فایل می نویسه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+writeLong(l: long): void</div>
                    <div class="tDataRTL">مقدار long رو داخل فایل می نویسه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+writeShort(sh: short): void</div>
                    <div class="tDataRTL">مقدار short رو داخل فایل می نویسه.</div>
                </div>


                <div class="tRow">
                    <div class="tDataLTR">+writeByte(b : byte): void</div>
                    <div class="tDataRTL">مقدار byte رو داخل فایل می نویسه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+writeChars(s: String): void</div>
                    <div class="tDataRTL">مقدار String رو داخل فایل می نویسه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+writeUTF(utf: String): void</div>
                    <div class="tDataRTL">مقدار String رو داخل به فرمت utf داخل فایل می نویسه.</div>
                </div>

            </div>


            <p>در مثال زیر میخوایم مقادیری رو با DataOutputStream در فایل بنویسیم و با DataInputStream همان مقادیر رو بخونیم.</p>

            <div class="sample">
                <div class="snippet-container">
                    <div class="snippet Java">
public static void main(String[] args) throws IOException{

    try(DataOutputStream output = new DataOutputStream(new FileOutputStream("temp.dat"))){
        output.writeUTF("John");
        output.writeDouble(45.5);
        output.writeUTF("Emily");
        output.writeDouble(50.2);
        output.writeUTF("Joseph");
        output.writeDouble(82.0);
    }

    try(DataInputStream input = new DataInputStream(new FileInputStream("temp.dat"))){
        while (input.available() > 0) {
            System.out.println("Name: " + input.readUTF() + " Score: " + input.readDouble());
        }
    }
}
                    </div>
                    <div class="snippet Kotlin">
fun main() {

val file = File("temp.dat")

    val output = FileOutputStream(file)

    val dataOutput = DataOutputStream(output)
    dataOutput.writeUTF("John")
    dataOutput.writeDouble(45.5)

    dataOutput.writeUTF("Emily")
    dataOutput.writeDouble(50.2)

    dataOutput.writeUTF("Joseph")
    dataOutput.writeDouble(82.0)

    dataOutput.close()

    val input = FileInputStream(file)
    val dataInput = DataInputStream(input)

    do {
        println("name: ${dataInput.readUTF()} score: ${dataInput.readDouble()}")
    }while (dataInput.available() > 0)

    output.close()
}
                    </div>
                </div>
            </div>



        </div>


        <div class="subsection" id="sub4">
            <p class="title">کلاس های ObjectInputStream و ObjectOutputStream در جاوا</p>

            <blockquote>برای نوشتن آبجکت در فایل باید آبجکت اینترفیس Serializable رو پیاده‌سازی کرده باشه.</blockquote>

            <p> این دو کلاس به ترتیب اینترفیس های ObjectInput و ObjectOutput رو پیاده‌سازی میکنن.</p>

            <p>تصویر زیر نحوه ی ارث بری این دو کلاس رو نشان می دهد.</p>

            <figure class="figure figure-wrapper">
                <img class="rounded figure-img" src="/resources/image/java/java_object_io_stream_inheritance.png" alt="نمودار uml نحوه ی ارث بری دو کلاس ObjectInputStream و ObjectOutputStream در جاوا"/>
                <figcaption class="figure-caption rtl">نمودار uml نحوه ی ارث بری دو کلاس ObjectInputStream و ObjectOutputStream در جاوا</figcaption>
            </figure>

            <p>همانطور که در تصویر مشاهده میکنید برای هردو کلاس یک کانستراکتور تعریف شده که هنگام نمونه سازی از ObjectInputStream و ObjectOutputStream میتونیم به ترتیب مقادیری از جنس InputStream و OutputStream رو به کانستراکتور هاشون پاس بدیم.</p>

            <p>اینترفیس های ObjectInput و ObjectOutput تمام متد های اینترفیس های DataInput و DataOutput رو به ارث می برند و دو متد readObject و writeObject هم داخلشون تعریف شده است.</p>


            <div class="tb" id="object-input-uml">
                <div class="tRow">
                    <div class="tHead">&lt;&lt;java.io.ObjectInput&gt;&gt;</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">readObject(): Object</div>
                    <div class="tDataRTL">یک آبجکت رو از فایل میخونه.</div>
                </div>
            </div>

            <p>همینطور که مشخصه در این اینترفیس علاوه بر متد های اینترفیس DataInput که به ارث می بره یک متد به اسم readObject تعریف شده است.</p>

            <div class="tb" id="object_output_uml">
                <div class="tRow">
                    <div class="tHead">&lt;&lt;java.io.ObjectOutput&gt;&gt;</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">writeObject(object: Object): void</div>
                    <div class="tDataRTL">یک آبجکت رو داخل فایل می نویسه.</div>
                </div>
            </div>

            <p>همینطور که مشخصه در این اینترفیس علاوه بر متد های اینترفیس DataOutput که به ارث می بره یک متد به اسم writeObject تعریف شده است.</p>

            <p>آبجکتی که میخوایم داخل فایل توسط ObjectOutputStream بنویسیم باید Serializable باشه در غیر این صورت دچار اکسپشن میشیم.</p>
            <p>اینترفیس Serializable متدی برای پیاده‌سازی نداره و صرفا یک برچسبه که به جاوا میگیم آبجکت های کلاس مورد نظر قابل نوشتن در فایل است.</p>

            <p>کلاس java.util.Date اینترفیس Serializable رو پیاده‌سازی کرده است. در مثال زیر آبجکت های کلاس Date رو داخل فایل می نویسیم و سپس با ObjectInputStream از فایل میخونیمشون.</p>

            <div class="sample">
                <div class="snippet-container">
                    <div class="snippet Java">
public static void main(String[] args) throws IOException, ClassNotFoundException{

    //نوشتن داده ها
    try(ObjectOutput output = new ObjectOutputStream(new FileOutputStream("temp.dat"))){
        output.writeUTF("John");
        output.writeDouble(45.5);
        output.writeObject(new Date());

        output.writeUTF("Emily");
        output.writeDouble(50.2);
        output.writeObject(new Date());

        output.writeUTF("Joseph");
        output.writeDouble(82.0);
        output.writeObject(new Date());
    }

    //خوندن داده ها
    try(ObjectInputStream input = new ObjectInputStream(new FileInputStream("temp.dat"))){
        while (input.available() > 0) {
            System.out.println("Name: " + input.readUTF() + " Score: " + input.readDouble() + " Date: " + input.readObject());
        }
}
                    </div>

                    <div class="snippet Kotlin">
fun main() {

    val file = File("temp.dat")

    //نوشتن داده ها
    val output = FileOutputStream(file)
    val objectOutput = ObjectOutputStream(output)

    objectOutput.writeUTF("John")
    objectOutput.writeDouble(45.5)
    objectOutput.writeObject(Date())

    objectOutput.writeUTF("Emily")
    objectOutput.writeDouble(50.2)
    objectOutput.writeObject(Date())

    objectOutput.writeUTF("Joseph")
    objectOutput.writeDouble(82.0)
    objectOutput.writeObject(Date())
    objectOutput.close()

    //خوندن داده ها
    val input = FileInputStream(file)
    val objectInput = ObjectInputStream(input)

    do {
        println("Name: ${objectInput.readUTF()} Score: ${objectInput.readDouble()} Date: ${objectInput.readObject()}")
    }while (objectInput.available() > 0)

    objectInput.close()
}
                    </div>
                </div>
            </div>

        </div>

        <div class="subsection" id="sub5">
            <p class="title">کلاس BufferedInputStream و BufferedOutputStream در جاوا</p>
            <blockquote>یاز BufferedInputStream و BufferedOutputStream برای خوندن یا نوشتن فایل هایی با حجم بیش از 100 یا 200 مگابایت استفاده میکنیم.</blockquote>
            <p>هر بار که عملیات خوندن یا نوشتن انجام میشه، کلاس های IO کرنل سیستم عامل رو صدا میزنن و از طریق کرنل و سایر اجزای سیستم عامل عملیات خوندن یا نوشتن رو انجام میدن؛ بنابراین خوندن و نوشتن فایل سنگین و هزینه بره.</p>
            <p>کلاس های BufferedInputStream و BufferedOutputStream دارای حافظه های موقتی به اسم buffer هستند که با هر عملیات خوندن یا نوشتن به‌جای اینکه مقادیر توسط سیستم عامل خونده یا نوشته بشه داخل حافظه ی buffer آبجکت این کلاس ها ذخیره میشه و زمانی که این حافظه پر شد داده ها توسط سیستم عامل خونده یا نوشته میشن.</p>
            <p>بنابراین میتونیم با این کلاس ها برنامه رو بهینه تر کنیم.</p>
            <p>حافظه ی پیشفرض buffer این کلاس ها ۵۱۲ بایت است که میتونیم داخل کد این حافظه رو تغییر داده و به مقدار دلخواه خود تنظیم کنیم.</p>


            <p>در نمودار uml زیر به بررسی BufferedInputStream پرداخته ایم:</p>
            <div class="tb" id="buffered_input_stream_uml">
                <div class="tRow">
                    <div class="tHead">java.io.BufferedInputStream</div>
                </div>
                <div class="tRow">
                    <div class="tDataLTR">+BufferedInputStream(in: InputStream)</div>
                    <div class="tDataRTL">یک نمونه از BufferedInputStream با حافظه ی buffer پیش فرض 512 بایت ایجاد میکنه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+BufferedInputStream(in: InputStream, bufferSize: int)</div>
                    <div class="tDataRTL">یک نمونه از BufferedInputStream با حافظه ی buffer دلخواه ایجاد میکنه.</div>
                </div>
            </div>

            <p>در نمودار uml زیر به بررسی BufferedOutputStream پرداخته ایم:</p>

            <div class="tb" id="buffered_output_stream_uml">
                <div class="tRow">
                    <div class="tHead">java.io.BufferedOutputStream</div>
                </div>
                <div class="tRow">
                    <div class="tDataLTR">+BufferedOutputStream(out: OutputStream)</div>
                    <div class="tDataRTL">یک نمونه از BufferedOutputStream با حافظه ی buffer پیش فرض 512 بایت ایجاد میکنه.</div>
                </div>

                <div class="tRow">
                    <div class="tDataLTR">+BufferedInputStream(in: OutputStream, bufferSize: int)</div>
                    <div class="tDataRTL">یک نمونه از BufferedOutputStream با حافظه ی buffer دلخواه ایجاد میکنه.</div>
                </div>
            </div>


            <p>در مثال زیر با استفاده از BufferedInputStream یک صد عدد تصادفی ۰ - ۲۵۵ (یک بایت) رو در فایل ذخیره میکنیم و سپس با BufferedInputStream اونا رو میخونیم.</p>

            <div class="sample">
                <div class="snippet-container">
                    <div class="snippet Java">
public static void main(String[] args) throws IOException {

    try(BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream("temp.dat"))){

        for (int i =0; i<100; i++){
            output.write((int)(Math.random() * 255));
        }
    }

    int numberOfBytesRead = 0;
    try(BufferedInputStream input = new BufferedInputStream(new FileInputStream("temp.dat"))) {
        int b;
        while ((b = input.read()) != -1){
            numberOfBytesRead ++;
            System.out.printf("%4d", b);
            if (numberOfBytesRead % 10 == 0)
            System.out.println();
        }
    }
}
                    </div>

                    <div class="snippet Kotlin">
fun main() {

    val file = File("temp.dat")

    val output = FileOutputStream(file)
    val bufferedOutput = BufferedOutputStream(output)

    for (i in 0 until 100){
        val data = Random.nextInt(0, 256)
        bufferedOutput.write(data)
    }
    bufferedOutput.close()

    val input = FileInputStream(file)
    val bufferedInput = BufferedInputStream(input)

    var numberOfBytesPerLine = 0
    do {
        numberOfBytesPerLine++
        print("${bufferedInput.read()} ")
        if (numberOfBytesPerLine % 10 == 0) {
            println()
        }
    }while (bufferedInput.available() > 0)

    bufferedInput.close()
}
                    </div>
                </div>
            </div>

        </div>


        <div class="subsection" id="sub6">
            <p class="title">مورد مطالعه (مثال)</p>
            <p>در مثال یک برنامه ی کاربردی است که از طریق کنسول (terminal یا cmd) یک فایل رو کپی میکنه.</p>

            <div class="sample">
                <div class="snippet-container">
                    <div class="snippet Java">
public static void main(String[] args) {

    if (args.length != 2) {
        System.out.println("Usage: java Copy source target");
        System.exit(1);
    }

    File source = new File(args[0]);
    if (!source.exists()) {
        System.out.println("Source file " + args[0] + " does not exist");
        System.exit(2);
    }

    File target = new File(args[1]);
    if (target.exists()) {
        System.out.println("Target file " + args[1] + " already exists");
        System.exit(3);
    }

    int b, numberOfBytesCopied = 0;

    try(
        BufferedInputStream input = new BufferedInputStream(new FileInputStream(source));
        BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(target));
    ) {

    while ((b = input.read()) != -1) {
        output.write((byte) b);
        numberOfBytesCopied++;
    }

    }catch (IOException e){
        e.fillInStackTrace();
    }finally {
        System.out.println("Copy ok!" + numberOfBytesCopied + " bytes copied");
    }
}
                    </div>
                    <div class="snippet Kotlin">
fun main(args: Array&lt;String&gt;) {

    if (args.size != 2){
        println("Usage: java Copy sourceFile target file")
        exitProcess(1)
    }

    val source = File(args[0])
    if (!source.exists()){
        println("Source file " + args[0] + " does not exist")
        exitProcess(2)
    }

    val target = File(args[1])
    if (target.exists()){
        println("Target file " + args[1] + " already exists")
        exitProcess(3)
    }

    val input = BufferedInputStream(FileInputStream(args[0]))
    val output = BufferedOutputStream(FileOutputStream(args[1]))

    var numberOfBytesCopied: Int = 0
    var b: Int
    do {
        b = input.read()
        if (b != -1) {
            output.write(b)
            numberOfBytesCopied++
        }
    }while (b != -1)

    input.close()
    output.close()

    println("Copy ok!$numberOfBytesCopied bytes copied")

}
                    </div>
                </div>
            </div>
        </div>

        <div class="subsection" id="sub7">
            <p class="title">خلاصه</p>
            <p>- تمام فایل ها به صورت باینری در کامپیوتر ذخیره میشن.</p>
            <p>- فایل های متنی کدگذاری شده هستند که هر کد مختص به یک حرف است.</p>
            <p>- به فرایند تبدیل کاراکتر (حرف) به کد متناظر خودش رمزنگاری (encoding) میگیم</p>
            <p>- به فرایند تبدیل کد به کاراکتر متناظر خودش رمزگشایی (decoding) میگیم.</p>
            <p>- خوندن و نوشتن به صورت باینری سریع تر از متنی است چون عملیات مستقیم و بدون رمزنگار یا رمزگشایی انجام میشه.</p>
            <p>- تمام کلاس های استریم پیکیج io در جاوا از دو کلاس InputStream و OutputStream ارث بری میکنن.</p>
            <p>- کلاس FileInputStream برای خوندن بایت های یک فایل و کلاس FileOutputStream برای نوشتن بایت ها در فایل مورد استفاده قرار میگیرن.</p>
            <p>- از دو کلاس DataInputStream و DataOutputStream برای خوندن و نوشتن مقادیر primitive استفاده میکنیم.</p>
            <p>- دو کلاس ObjectInputStream و ObjectOutputStream علاوه بر مقادیر primitive آبجکت هایی که Serializable هستند رو نیز برای خوندن و نوشتن پشتیبانی میکنن.</p>
            <p>- دو کلاس BufferedInputStream و BufferedOutputStream برای فایل هایی با حجم بالا مورد استفاده قرار میگیرند.</p>
        </div>

    </article>

    <div class="article-foot">

      <div class="navigator-container">

        <a href="#" class="md-bt md-bt-light">

            <span class="material-icons">
              navigate_next
            </span>
          <span class="hint">
              قبلی
            </span>
        </a>

        <a href="#" class="md-bt md-bt-light">
            <span class="hint">
              قبلی
            </span>
          <span class="material-icons">
              navigate_before
            </span>

        </a>
      </div>

      <div class="relative-articles-container">
        <p>مطالب مرتبط</p>
        <div class="d-flex flex-wrap">
          <div>
            <a href="objects-and-classes.html">آبجکت و کلاس ها در جاوا</a>
          </div>

          <div>
            <a href="inheritance.html">وراثت در جاوا</a>
          </div>

            <div>
                <a href="interfaces.html">اینترفیس ها در جاوا</a>
            </div>

            <div>
                <a href="exceptions.html">اکسپشن ها در جاوا</a>
            </div>

            <div>
                <a href=""></a>
            </div>

          <div>
            <a href="">مطالعه در وبسایت رسمی کاتلین</a>
          </div>
        </div>
      </div>
    </div>

  </div>
</main>

<div class="scroll-top-container">
  <a class="text-decoration-none link-dark material-icons" href="#">
    arrow_drop_up
  </a>
</div>

<footer></footer>

<div class="copy-message">
  <span class="copy-message-text">کپی شد!</span>
</div>
</body>

</html>